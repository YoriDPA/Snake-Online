<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake Online - por Yoridpa</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos personalizados para o jogo */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Evita barras de rolagem */
            touch-action: none; /* Desabilita zoom por toque, etc. */
        }
        /* Garante que o canvas não estoure a tela em modo tela cheia */
        canvas:fullscreen {
            width: 100%;
            height: 100%;
        }
        /* Estilo para os botões de controle mobile */
        .touch-control-btn {
            width: 64px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 28px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }
        .touch-control-btn:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen">

    <header class="text-center flex-shrink-0 pt-4 px-4">
        <h1 class="text-3xl md:text-4xl font-bold text-emerald-400">Snake Online</h1>
        <p class="text-sm text-gray-400">Criado por Yoridpa</p>
        <div id="score" class="text-xl md:text-2xl font-medium mt-2">Pontuação: 0</div>
    </header>

    <main class="flex-grow flex items-center justify-center relative py-2">
        <div class="relative w-full h-full flex items-center justify-center">
            <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl"></canvas>
            
            <!-- Modal de Fim de Jogo -->
            <div id="gameOverModal" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden">
                <h2 class="text-4xl font-bold text-red-500 mb-2">Fim de Jogo!</h2>
                <p id="finalScore" class="text-xl mb-6">Sua pontuação: 0</p>
                <button id="restartBtn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300">
                    Jogar Novamente
                </button>
            </div>

            <!-- Botão de Tela Cheia Sobreposto -->
            <button id="fullscreen-btn" class="absolute top-2 right-2 bg-gray-700/50 hover:bg-gray-600/70 p-2 rounded-full transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
            </button>

            <!-- Controles de Toque Sobrepostos -->
            <div class="absolute inset-0 md:hidden">
                <div class="absolute bottom-5 left-5 flex gap-10 opacity-75">
                    <button id="left-btn" class="touch-control-btn">◄</button>
                    <button id="right-btn" class="touch-control-btn">►</button>
                </div>
                <div class="absolute bottom-5 right-5 flex flex-col gap-5 opacity-75">
                    <button id="up-btn" class="touch-control-btn">▲</button>
                    <button id="down-btn" class="touch-control-btn">▼</button>
                </div>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementos do DOM ---
            const mainElement = document.querySelector('main');
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const gameOverModal = document.getElementById('gameOverModal');
            const finalScoreDisplay = document.getElementById('finalScore');
            const restartBtn = document.getElementById('restartBtn');

            // --- Configurações do Jogo ---
            const gridSize = 20;
            let tileCount;
            let snake, food, dx, dy, score, gameLoop;
            let changingDirection = false;

            // --- Funções do Jogo ---

            function resizeCanvas() {
                const availableWidth = mainElement.clientWidth;
                const availableHeight = mainElement.clientHeight;
                
                const size = Math.min(availableWidth, availableHeight) * 0.98; // Usa 98% para uma pequena margem
                
                canvas.width = Math.floor(size / gridSize) * gridSize;
                canvas.height = canvas.width;
                
                const modalContainer = gameOverModal.parentElement;
                modalContainer.style.width = `${canvas.width}px`;
                modalContainer.style.height = `${canvas.height}px`;

                tileCount = canvas.width / gridSize;
                initializeGame();
            }

            function initializeGame() {
                snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
                dx = 0;
                dy = 0;
                score = 0;
                changingDirection = false;
                scoreDisplay.textContent = `Pontuação: ${score}`;
                gameOverModal.classList.add('hidden');
                gameOverModal.classList.remove('flex');
                
                generateFood();

                if (gameLoop) clearInterval(gameLoop);
                gameLoop = setInterval(gameTick, 150); 
            }

            function gameTick() {
                if (dx === 0 && dy === 0) {
                    draw();
                    return;
                }

                changingDirection = false;
                const head = { x: snake[0].x + dx, y: snake[0].y + dy };

                if (hasWallCollision(head)) {
                    gameOver();
                    return;
                }

                snake.unshift(head);

                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    scoreDisplay.textContent = `Pontuação: ${score}`;
                    generateFood();
                    triggerHapticFeedback(50); 
                } else {
                    snake.pop();
                }

                draw();
            }
            
            function triggerHapticFeedback(pattern) {
                if (window.navigator && window.navigator.vibrate) {
                    window.navigator.vibrate(pattern);
                }
            }

            function draw() {
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#ef4444';
                ctx.strokeStyle = '#f87171';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                snake.forEach((segment, index) => {
                    const gradient = ctx.createLinearGradient(
                        segment.x * gridSize, segment.y * gridSize,
                        segment.x * gridSize + gridSize, segment.y * gridSize + gridSize
                    );
                    gradient.addColorStop(0, '#34d399');
                    gradient.addColorStop(1, '#10b981');
                    ctx.fillStyle = gradient;
                    
                    if (index === 0) {
                        ctx.beginPath();
                        ctx.arc(segment.x * gridSize + gridSize / 2, segment.y * gridSize + gridSize / 2, gridSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    } else {
                        ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    }
                });
            }

            function generateFood() {
                let newFoodPosition;
                do {
                    newFoodPosition = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                } while (isFoodOnSnake(newFoodPosition));
                food = newFoodPosition;
            }

            function isFoodOnSnake(position) {
                return snake.some(segment => segment.x === position.x && segment.y === position.y);
            }

            function hasWallCollision(head) {
                return head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount;
            }

            function gameOver() {
                clearInterval(gameLoop);
                finalScoreDisplay.textContent = `Sua pontuação: ${score}`;
                gameOverModal.classList.remove('hidden');
                gameOverModal.classList.add('flex');
                triggerHapticFeedback([200, 50, 100]); 
            }

            // --- Event Listeners ---

            document.addEventListener('keydown', e => {
                if (changingDirection) return;
                changingDirection = true;

                const goingUp = dy === -1;
                const goingDown = dy === 1;
                const goingLeft = dx === -1;
                const goingRight = dx === 1;

                switch (e.key) {
                    case 'ArrowUp': case 'w':
                        if (!goingDown) { dx = 0; dy = -1; }
                        break;
                    case 'ArrowDown': case 's':
                        if (!goingUp) { dx = 0; dy = 1; }
                        break;
                    case 'ArrowLeft': case 'a':
                        if (!goingRight) { dx = -1; dy = 0; }
                        break;
                    case 'ArrowRight': case 'd':
                        if (!goingLeft) { dx = 1; dy = 0; }
                        break;
                }
            });

            document.getElementById('up-btn').addEventListener('click', () => { if (dy !== 1) { dx = 0; dy = -1; } });
            document.getElementById('down-btn').addEventListener('click', () => { if (dy !== -1) { dx = 0; dy = 1; } });
            document.getElementById('left-btn').addEventListener('click', () => { if (dx !== 1) { dx = -1; dy = 0; } });
            document.getElementById('right-btn').addEventListener('click', () => { if (dx !== -1) { dx = 1; dy = 0; } });

            let touchStartX = 0;
            let touchStartY = 0;
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!touchStartX || !touchStartY) return;

                const touchEndX = e.touches[0].clientX;
                const touchEndY = e.touches[0].clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0 && dx !== -1) { dx = 1; dy = 0; }
                    else if (diffX < 0 && dx !== 1) { dx = -1; dy = 0; }
                } else {
                    if (diffY > 0 && dy !== -1) { dx = 0; dy = 1; }
                    else if (diffY < 0 && dy !== 1) { dx = 0; dy = -1; }
                }

                touchStartX = 0;
                touchStartY = 0;
            }, { passive: false });

            restartBtn.addEventListener('click', initializeGame);

            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    canvas.requestFullscreen().catch(err => {
                        // CORREÇÃO: O erro é ignorado silenciosamente para evitar a mensagem na consola.
                    });
                } else {
                    document.exitFullscreen();
                }
            });
            
            document.addEventListener('fullscreenchange', () => {
                setTimeout(resizeCanvas, 100); 
            });

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        });
    </script>
</body>
</html>
